/**
 * @file ESP8266.cpp
 * @brief The implementation of class ESP8266. 
 * @author Wu Pengfei<pengfei.wu@itead.cc> 
 * @date 2015.02
 * 
 * @par Copyright:
 * Copyright (c) 2015 ITEAD Intelligent Systems Co., Ltd. \n\n
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version. \n\n
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
#include <ESP8266.h>
#include <SoftwareSerial.h>
#include <avr/pgmspace.h>
#include <MemoryFree.h>

#define ESP_BAUD_RATE 115200

#define DBG_RX_PIN 13
#define DBG_TX_PIN 12

SoftwareSerial debugSerial(DBG_RX_PIN, DBG_TX_PIN);

ESP8266::ESP8266() {

}

void ESP8266::begin(void) {
	Serial.begin(ESP_BAUD_RATE);
	Serial.setTimeout(10000);

	debugSerial.begin(ESP_BAUD_RATE);
	printFreeMem();

	rx_empty();
}

bool ESP8266::kick(void) {
	return eAT();
}

bool ESP8266::restart(void) {
	unsigned long start;
	if (eATRST()) {
		delay(2000);
		start = millis();
		while (millis() - start < 3000) {
			if (eAT()) {
				delay(1500); /* Waiting for stable */
				return true;
			}
			delay(100);
		}
	}
	return false;
}

String ESP8266::getVersion(void) {
	String version;
	eATGMR(version);
	return version;
}

bool ESP8266::setOprToStation(void) {
	uint8_t mode;
	if (!qATCWMODE(&mode)) {
		return false;
	}
	if (mode == 1) {
		return true;
	} else {
		if (sATCWMODE(1) && restart()) {
			return true;
		} else {
			return false;
		}
	}
}

bool ESP8266::setOprToSoftAP(void) {
	uint8_t mode;
	if (!qATCWMODE(&mode)) {
		return false;
	}
	if (mode == 2) {
		return true;
	} else {
		if (sATCWMODE(2) && restart()) {
			return true;
		} else {
			return false;
		}
	}
}

bool ESP8266::setOprToStationSoftAP(void) {
	uint8_t mode;
	if (!qATCWMODE(&mode)) {
		return false;
	}
	if (mode == 3) {
		return true;
	} else {
		if (sATCWMODE(3) && restart()) {
			return true;
		} else {
			return false;
		}
	}
}

String ESP8266::getAPList(void) {
	String list;
	eATCWLAP(list);
	return list;
}

bool ESP8266::joinAP(String ssid, String pwd) {
	return sATCWJAP(ssid, pwd);
}

bool ESP8266::leaveAP(void) {
	return eATCWQAP();
}

bool ESP8266::setSoftAPParam(String ssid, String pwd, uint8_t chl,
		uint8_t ecn) {
	return sATCWSAP(ssid, pwd, chl, ecn);
}

String ESP8266::getJoinedDeviceIP(void) {
	String list;
	eATCWLIF(list);
	return list;
}

String ESP8266::getIPStatus(void) {
	String list;
	eATCIPSTATUS(list);
	return list;
}

String ESP8266::getLocalIP(void) {
	String list;
	eATCIFSR(list);
	return list;
}

String ESP8266::getApMac(void) {
	String list;
	eATCIPAPMACCUR(list);
	list.replace("+CIPAPMAC_CUR:\"", "");
	list.replace("\"", "");
	list.replace(":", "");
	return list;
}

bool ESP8266::enableMUX(void) {
	return sATCIPMUX(1);
}

bool ESP8266::disableMUX(void) {
	return sATCIPMUX(0);
}

bool ESP8266::createTCP(String addr, uint32_t port) {
	return sATCIPSTARTSingle("TCP", addr, port);
}

bool ESP8266::releaseTCP(void) {
	return eATCIPCLOSESingle();
}

bool ESP8266::registerUDP(String addr, uint32_t port) {
	return sATCIPSTARTSingle("UDP", addr, port);
}

bool ESP8266::unregisterUDP(void) {
	return eATCIPCLOSESingle();
}

bool ESP8266::createTCP(uint8_t mux_id, String addr, uint32_t port) {
	return sATCIPSTARTMultiple(mux_id, "TCP", addr, port);
}

bool ESP8266::releaseTCP(uint8_t mux_id) {
	return sATCIPCLOSEMulitple(mux_id);
}

bool ESP8266::registerUDP(uint8_t mux_id, String addr, uint32_t port) {
	return sATCIPSTARTMultiple(mux_id, "UDP", addr, port);
}

bool ESP8266::unregisterUDP(uint8_t mux_id) {
	return sATCIPCLOSEMulitple(mux_id);
}

bool ESP8266::setTCPServerTimeout(uint32_t timeout) {
	return sATCIPSTO(timeout);
}

bool ESP8266::startTCPServer(uint32_t port) {
	if (sATCIPSERVER(1, port)) {
		return true;
	}
	return false;
}

bool ESP8266::stopTCPServer(void) {
	sATCIPSERVER(0);
	restart();
	return false;
}

bool ESP8266::startServer(uint32_t port) {
	return startTCPServer(port);
}

bool ESP8266::stopServer(void) {
	return stopTCPServer();
}

bool ESP8266::send(const uint8_t *buffer, uint32_t len) {
	return sATCIPSENDSingle(buffer, len);
}

bool ESP8266::send(uint8_t mux_id, const uint8_t *buffer, uint32_t len) {
	return sATCIPSENDMultiple(mux_id, buffer, len);
}

uint32_t ESP8266::recv(uint8_t *buffer, uint32_t buffer_size,
		uint32_t timeout) {
	return recvPkg(buffer, buffer_size, NULL, timeout, NULL);
}

bool ESP8266::recvHTTP(uint32_t timeout) {
	uint8_t responseBuffer[128] = { 0 };
	uint32_t len = recvPkg(responseBuffer, sizeof(responseBuffer), NULL, 10000, NULL);
	String data_tmp;
	String target = "200 OK";
	if (len > 0) {
//		if (data_tmp.length() > 0) {
		for (uint32_t i = 0; i < len; i++) {
			data_tmp += (char) responseBuffer[i];
		}
		if (data_tmp.indexOf(target) != -1) {
			return true;
		}
	}
	return false;
}

uint32_t ESP8266::recv(uint8_t mux_id, uint8_t *buffer, uint32_t buffer_size,
		uint32_t timeout) {
	uint8_t id;
	uint32_t ret;
	ret = recvPkg(buffer, buffer_size, NULL, timeout, &id);
	if (ret > 0 && id == mux_id) {
		return ret;
	}
	return 0;
}

uint32_t ESP8266::recv(uint8_t *coming_mux_id, uint8_t *buffer,
		uint32_t buffer_size, uint32_t timeout) {
	return recvPkg(buffer, buffer_size, NULL, timeout, coming_mux_id);
}

/*----------------------------------------------------------------------------*/
/* +IPD,<id>,<len>:<data> */
/* +IPD,<len>:<data> */

uint32_t ESP8266::recvPkg(uint8_t *buffer, uint32_t buffer_size,
		uint32_t *data_len, uint32_t timeout, uint8_t *coming_mux_id) {
	printFreeMem();
	String data;
	char a;
	int16_t index_PIPDcomma = -1;
	int16_t index_colon = -1; /* : */
	int16_t index_comma = -1; /* , */
	int16_t len = -1;
	int8_t id = -1;
	bool has_data = false;
	uint32_t ret;
	unsigned long start;
	uint32_t i;

	if (buffer == NULL) {
		return 0;
	}

	start = millis();
	debugSerial.println(F("Waiting for response"));
	while (millis() - start < timeout) {
		if (Serial.available() > 0) {
			a = Serial.read();
			data += a;
		}

		index_PIPDcomma = data.indexOf("+IPD,");
		if (index_PIPDcomma != -1) {
			index_colon = data.indexOf(':', index_PIPDcomma + 5);
			if (index_colon != -1) {
				index_comma = data.indexOf(',', index_PIPDcomma + 5);
				/* +IPD,id,len:data */
				if (index_comma != -1 && index_comma < index_colon) {
					id =
							data.substring(index_PIPDcomma + 5, index_comma).toInt();
					if (id < 0 || id > 4) {
						return 0;
					}
					len = data.substring(index_comma + 1, index_colon).toInt();
					if (len <= 0) {
						return 0;
					}
				} else { /* +IPD,len:data */
					len =
							data.substring(index_PIPDcomma + 5, index_colon).toInt();
					if (len <= 0) {
						return 0;
					}
				}
				has_data = true;
				break;
			}
		}
	}

	if (has_data) {
		debugSerial.println("Got data");
		i = 0;
		ret = (unsigned) len > buffer_size ? buffer_size : len;
		start = millis();
		while (millis() - start < 3000) {
			while (Serial.available() > 0 && i < ret) {
				a = Serial.read();
				buffer[i++] = a;
			}
			if (i == ret) {
				rx_empty();
				if (data_len) {
					*data_len = len;
				}
				if (index_comma != -1 && coming_mux_id) {
					*coming_mux_id = id;
				}
				return ret;
			}
		}
	}
	return 0;
}

void ESP8266::rx_empty(void) {
	while (Serial.available() > 0) {
		Serial.read();
		delay(1);
	}
}

void ESP8266::timed_rx_empty(uint32_t timeout) {
	unsigned long start;
	start = millis();
	while (millis() - start < timeout) {
		rx_empty();
		delay(1);
	}
}


String ESP8266::recvString(String target, uint32_t timeout) {
	String data;
	char a;
	unsigned long start = millis();
	while (millis() - start < timeout) {
		while (Serial.available() > 0) {
			a = Serial.read();
			if (a == '\0')
				continue;
			data += a;
		}
		if (data.indexOf(target) != -1) {
			break;
		}
	}
	debugSerial.print(F("RecvString: "));
	debugSerial.println(data);
	return data;
}

String ESP8266::recvString(String target1, String target2, uint32_t timeout) {
	String data;
	char a;
	unsigned long start = millis();
	while (millis() - start < timeout) {
		while (Serial.available() > 0) {
			a = Serial.read();
			if (a == '\0')
				continue;
			data += a;
		}
		if (data.indexOf(target1) != -1) {
			break;
		} else if (data.indexOf(target2) != -1) {
			break;
		}
	}
	return data;
}

String ESP8266::recvString(String target1, String target2, String target3,
		uint32_t timeout) {
	String data;
	char a;
	unsigned long start = millis();
	while (millis() - start < timeout) {
		while (Serial.available() > 0) {
			a = Serial.read();
			if (a == '\0')
				continue;
			data += a;
		}
		if (data.indexOf(target1) != -1) {
			break;
		} else if (data.indexOf(target2) != -1) {
			break;
		} else if (data.indexOf(target3) != -1) {
			break;
		}
	}
	debugSerial.print(F("recvString data:"));
	debugSerial.println(data);
	return data;
}

bool ESP8266::recvFind(String target, uint32_t timeout) {
	String data_tmp;
	data_tmp = recvString(target, timeout);
	debugSerial.print(F("data_tmp:"));
	debugSerial.println(data_tmp);
	if (data_tmp.indexOf(target) != -1) {
		return true;
	}
	return false;
}

bool ESP8266::recvFindAndFilter(String target, String begin, String end,
		String &data, uint32_t timeout) {
	String data_tmp;
	data_tmp = recvString(target, timeout);
	debugSerial.println(F("recvFindAndFilter data_tmp: "));
	debugSerial.println(data_tmp);
	if (data_tmp.indexOf(target) != -1) {
		int32_t index1 = data_tmp.indexOf(begin);
		int32_t index2 = data_tmp.indexOf(end);
		if (index1 != -1 && index2 != -1) {
			index1 += begin.length();
			data = data_tmp.substring(index1, index2);
			return true;
		}
	}
	data = "";
	return false;
}

bool ESP8266::eAT(void) {
	rx_empty();
	Serial.println(F("AT"));
	return recvFind("OK");
}

bool ESP8266::eATRST(void) {
	rx_empty();
	Serial.println(F("AT+RST"));
	return recvFind("OK");
}

bool ESP8266::eATGMR(String &version) {
	rx_empty();
	Serial.println(F("AT+GMR"));
	return recvFindAndFilter("OK", "\r\r\n", "\r\nOK", version);
}

bool ESP8266::qATCWMODE(uint8_t *mode) {
	String str_mode;
	bool ret;
	if (!mode) {
		return false;
	}
	rx_empty();
	Serial.println(F("AT+CWMODE?"));
	ret = recvFindAndFilter("OK", "+CWMODE:", "\r\n\r\nOK", str_mode);
	if (ret) {
		*mode = (uint8_t) str_mode.toInt();
		return true;
	} else {
		return false;
	}
}

bool ESP8266::sATCWMODE(uint8_t mode) {
	String data;
	rx_empty();
	Serial.print(F("AT+CWMODE="));
	Serial.println(mode);

	data = recvString("OK", "no change");
	if (data.indexOf("OK") != -1 || data.indexOf("no change") != -1) {
		return true;
	}
	return false;
}

bool ESP8266::sATCWJAP(String ssid, String pwd) {
	String data;
	rx_empty();
	Serial.print(F("AT+CWJAP=\""));
	Serial.print(ssid);
	Serial.print(F("\",\""));
	Serial.print(pwd);
	Serial.println(F("\""));

	data = recvString("OK", "FAIL", 20000);
	if (data.indexOf("OK") != -1) {
		return true;
	}
	return false;
}

bool ESP8266::eATCWLAP(String &list) {
	rx_empty();
	Serial.println(F("AT+CWLAP"));
	return recvFindAndFilter("OK", "\r\n", "\r\n\r\nOK", list, 10000);
}

bool ESP8266::eATCWQAP(void) {
	rx_empty();
	Serial.println(F("AT+CWQAP"));
	return recvFind("OK");
}

bool ESP8266::sATCWSAP(String ssid, String pwd, uint8_t chl, uint8_t ecn) {
	String data;
	rx_empty();
	Serial.print(F("AT+CWSAP=\""));
	Serial.print(ssid);
	Serial.print(F("\",\""));
	Serial.print(pwd);
	Serial.print(F("\","));
	Serial.print(chl);
	Serial.print(F(","));
	Serial.println(ecn);

	data = recvString("OK", "ERROR", 5000);
	if (data.indexOf("OK") != -1) {
		return true;
	}
	return false;
}

bool ESP8266::eATCWLIF(String &list) {
	rx_empty();
	Serial.println(F("AT+CWLIF"));
	return recvFindAndFilter("OK", "\r\r\n", "\r\n\r\nOK", list);
}
bool ESP8266::eATCIPSTATUS(String &list) {
	//Added because data was still streaming across from results from the HTTP request
	timed_rx_empty(1000);

//	delay(500);
//	timed_rx_empty(1000);
	Serial.println(F("AT+CIPSTATUS"));
	delay(500);
	return recvFindAndFilter("OK", "\r\r\n", "\r\n\r\nOK", list);
}
bool ESP8266::sATCIPSTARTSingle(String type, String addr, uint32_t port) {
	String data;
	rx_empty();
	Serial.print(F("AT+CIPSTART=\""));
	Serial.print(type);
	Serial.print(F("\",\""));
	Serial.print(addr);
	Serial.print(F("\","));
	Serial.println(port);

	data = recvString("OK", "ERROR", "ALREADY CONNECT", 10000);
	if (data.indexOf("OK") != -1 || data.indexOf("ALREADY CONNECT") != -1) {
		return true;
	}
	return false;
}
bool ESP8266::sATCIPSTARTMultiple(uint8_t mux_id, String type, String addr,
		uint32_t port) {
	String data;
	rx_empty();
	Serial.print(F("AT+CIPSTART="));
	Serial.print(mux_id);
	Serial.print(F(",\""));
	Serial.print(type);
	Serial.print(F("\",\""));
	Serial.print(addr);
	Serial.print(F("\","));
	Serial.println(port);

	data = recvString("OK", "ERROR", "ALREADY CONNECT", 10000);
	if (data.indexOf("OK") != -1 || data.indexOf("ALREADY CONNECT") != -1) {
		return true;
	}
	return false;
}
bool ESP8266::sATCIPSENDSingle(const uint8_t *buffer, uint32_t len) {
	rx_empty();
	debugSerial.println(F("Trying send"));
	debugSerial.print(F("AT+CIPSEND="));
	debugSerial.println(len);
	Serial.print(F("AT+CIPSEND="));
	Serial.println(len);
	if (recvFind(">", 5000)) {
		debugSerial.println(F("Got >, writing request to serial"));
		rx_empty();
		for (uint32_t i = 0; i < len; i++) {
			Serial.write(buffer[i]);
			debugSerial.write(buffer[i]);
		}
		debugSerial.println(F("Waiting for SEND OK"));
		return recvFind("SEND OK", 10000);
	}
	return false;
}
bool ESP8266::sATCIPSENDMultiple(uint8_t mux_id, const uint8_t *buffer,
		uint32_t len) {
	rx_empty();
	Serial.print(F("AT+CIPSEND="));
	Serial.print(mux_id);
	Serial.print(F(","));
	Serial.println(len);
	if (recvFind(">", 5000)) {
		rx_empty();
		for (uint32_t i = 0; i < len; i++) {
			Serial.write(buffer[i]);
		}
		return recvFind("SEND OK", 10000);
	}
	return false;
}
bool ESP8266::sATCIPCLOSEMulitple(uint8_t mux_id) {
	String data;
	rx_empty();
	Serial.print(F("AT+CIPCLOSE="));
	Serial.println(mux_id);

	data = recvString("OK", "link is not", 5000);
	if (data.indexOf("OK") != -1 || data.indexOf("link is not") != -1) {
		return true;
	}
	return false;
}
bool ESP8266::eATCIPCLOSESingle(void) {
	rx_empty();
	Serial.println(F("AT+CIPCLOSE"));
	return recvFind("OK", 5000);
}
bool ESP8266::eATCIFSR(String &list) {
	rx_empty();
	Serial.println(F("AT+CIFSR"));
	return recvFindAndFilter("OK", "\r\r\n", "\r\n\r\nOK", list);
}

bool ESP8266::eATCIPAPMACCUR(String &list) {
	rx_empty();
	Serial.println(F("AT+CIPAPMAC_CUR?"));
	return recvFindAndFilter("OK", "\r\n", "\r\n\r\nOK", list);
}

bool ESP8266::sATCIPMUX(uint8_t mode) {
	String data;
	rx_empty();
	Serial.print(F("AT+CIPMUX="));
	Serial.println(mode);

	data = recvString("OK", "Link is built");
	if (data.indexOf("OK") != -1) {
		return true;
	}
	return false;
}
bool ESP8266::sATCIPSERVER(uint8_t mode, uint32_t port) {
	String data;
	if (mode) {
		rx_empty();
		Serial.print(F("AT+CIPSERVER=1,"));
		Serial.println(port);

		data = recvString("OK", "no change");
		if (data.indexOf("OK") != -1 || data.indexOf("no change") != -1) {
			return true;
		}
		return false;
	} else {
		rx_empty();
		Serial.println(F("AT+CIPSERVER=0"));
		return recvFind("\r\r\n");
	}
}
bool ESP8266::sATCIPSTO(uint32_t timeout) {
	rx_empty();
	Serial.print(F("AT+CIPSTO="));
	Serial.println(timeout);
	return recvFind("OK");
}

void ESP8266::printFreeMem() {
	debugSerial.print(F("freeMemory()="));
	debugSerial.println(freeMemory());
}

